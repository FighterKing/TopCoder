#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;


class RedAndGreen {
public:
  int minPaints(string row) {
    int size = row.size();
    int *a = new int[size], *b = new int[size];
    fill(a, a + size, 0);
    fill(b, b + size, 0);
    int i = 0;
    int count = 0;
    for (; i < size; ++i) {
      if ('G' == row[i])
        ++count;
      a[i] = count;
    }
    count = 0;
    for (i = size - 1; i >= 0; --i) {
      if ('R' == row[i])
        ++count;
      b[i] = count;
    }
    
    int minCount = min(b[0], a[size - 1]);
    for (i = 0; i < size - 1; ++i) {
      if (a[i] + b[i + 1] < minCount)
        minCount = a[i] + b[i + 1];
    }
    delete []a;
    delete []b;
    return minCount;
  }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, bool hasAnswer, int p1) {
  cout << "Test " << testNum << ": [" << "\"" << p0 << "\"";
  cout << "]" << endl;
  RedAndGreen *obj;
  int answer;
  obj = new RedAndGreen();
  clock_t startTime = clock();
  answer = obj->minPaints(p0);
  clock_t endTime = clock();
  delete obj;
  bool res;
  res = true;
  cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
  if (hasAnswer) {
    cout << "Desired answer:" << endl;
    cout << "\t" << p1 << endl;
  }
  cout << "Your answer:" << endl;
  cout << "\t" << answer << endl;
  if (hasAnswer) {
    res = answer == p1;
  }
  if (!res) {
    cout << "DOESN'T MATCH!!!!" << endl;
  } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
    cout << "FAIL the timeout" << endl;
    res = false;
  } else if (hasAnswer) {
    cout << "Match :-)" << endl;
  } else {
    cout << "OK, but is it right?" << endl;
  }
  cout << "" << endl;
  return res;
}
int main() {
  bool all_right;
  all_right = true;
	
  string p0;
  int p1;
	
  {
    // ----- test 0 -----
    p0 = "RGRGR";
    p1 = 2;
    all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 1 -----
    p0 = "RRRGGGGG";
    p1 = 0;
    all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 2 -----
    p0 = "GGGGRRR";
    p1 = 3;
    all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 3 -----
    p0 = "RGRGRGRGRGRGRGRGR";
    p1 = 8;
    all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 4 -----
    p0 = "RRRGGGRGGGRGGRRRGGRRRGR";
    p1 = 9;
    all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
    // ------------------
  }
	
  if (all_right) {
    cout << "You're a stud (at least on the example cases)!" << endl;
  } else {
    cout << "Some of the test cases had errors." << endl;
  }
  return 0;
}
// PROBLEM STATEMENT
// 
// You have several squares arranged in a single row. Each square is currently painted red or green. You can choose any of the squares and paint it over with either color. The goal is that, after painting, every red square is further to the left than any of the green squares. We want you to do it repainting the minimum possible number of squares.
// 
// Squares are numbered from left to right. You will be given the initial arrangement as a string row, such that character i is 'R' if square i is red or 'G' if square i is green. Return the minimum number of repaints needed to achieve the goal.
// 
// 
// DEFINITION
// Class:RedAndGreen
// Method:minPaints
// Parameters:string
// Returns:int
// Method signature:int minPaints(string row)
// 
// 
// CONSTRAINTS
// -row will contain between 1 and 50 characters, inclusive.
// -Each character of row will be either 'R' or 'G'.
// 
// 
// EXAMPLES
// 
// 0)
// "RGRGR"
// 
// Returns: 2
// 
// Paint the squares in the marked positions in the picture below with the opposite color. There are other ways with 2 total paints.
// 
// RGRGR
//  |  |
// RRRGG
// 
// 
// 1)
// "RRRGGGGG"
// 
// Returns: 0
// 
// There is no need to paint anything.
// 
// 2)
// "GGGGRRR"
// 
// Returns: 3
// 
// Paint all the red squares green.
// 
// 3)
// "RGRGRGRGRGRGRGRGR"
// 
// Returns: 8
// 
// 
// 
// 4)
// "RRRGGGRGGGRGGRRRGGRRRGR"
// 
// Returns: 9
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

