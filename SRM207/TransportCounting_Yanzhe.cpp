#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;


class TransportCounting {
public:
	int countBuses(int speed, vector <int> positions, vector <int> velocities, int time) {
		int maxdis = speed * time;
		int N = positions.size();
		int ret = 0;
		for (int i = 0; i < N; i++) {
			if (positions[i] == 0)
				ret++;
			else if (maxdis >= positions[i] + velocities[i] * time)
				ret++;
		}
		return ret;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, vector <int> p2, int p3, bool hasAnswer, int p4) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}" << "," << p3;
	cout << "]" << endl;
	TransportCounting *obj;
	int answer;
	obj = new TransportCounting();
	clock_t startTime = clock();
	answer = obj->countBuses(p0, p1, p2, p3);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p4 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p4;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	vector <int> p1;
	vector <int> p2;
	int p3;
	int p4;
	
	{
	// ----- test 0 -----
	p0 = 100;
	int t1[] = {0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 0;
	p4 = 1;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 5;
	int t1[] = {10,10};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,1};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 2;
	p4 = 1;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 5;
	int t1[] = {10,10};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,1};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 3;
	p4 = 2;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 777;
	int t1[] = {10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 333;
	p4 = 50;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 5;
	int t1[] = {0,0,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {4,5,6};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 10;
	p4 = 3;
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You are studying public transportation, and you want to know how many buses are going down a particular one-way street every minute. You are driving along the street by car, and counting the buses you meet or overtake. After some time, you stop counting and report the result. In this problem, you may assume that the street is a straight line, and that your car and all of the buses can only go along this line in the same direction.
// 
// 
// You will be given an int, speed, giving your speed in meters per minute. You will also be given a vector <int> positions, specifying how far ahead of you each of the buses is in meters at time 0, and a vector <int> velocities, specifying the velocities of the buses in meters per minute. The ith element of velocities and the ith element of positions specify the velocity and position of the ith bus, respectively.
// 
// Finally, an int, time, tells you how many minutes you should count the buses you pass for.
// 
// 
// You should return the number of buses you will overtake or meet during time minutes. If you meet one or several buses at the first or at the final moment, count them also.
// 
// DEFINITION
// Class:TransportCounting
// Method:countBuses
// Parameters:int, vector <int>, vector <int>, int
// Returns:int
// Method signature:int countBuses(int speed, vector <int> positions, vector <int> velocities, int time)
// 
// 
// CONSTRAINTS
// -positions and velocities will contain the same number of elements.
// -positions  will contain between 0 and 50 elements, inclusive.
// -speed and time will both be between 0 and 1000 inclusive.
// -All elements of positions and velocities will be between 0 and 1000, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 100
// {0}
// {0}
// 0
// 
// Returns: 1
// 
// Though the duration of your counting is 0, you still can count the first bus.
// 
// 1)
// 5
// {10, 10}
// {0, 1}
// 2
// 
// Returns: 1
// 
// There are two buses.
// The first bus starts 10 meters from you and does not move - so you will reach it in the final moment of your measurement.
// The second bus starts from the same point as the first one, but goes away from you, covering 1 meter per minute. Thus you won't catch it.
// 
// 2)
// 5
// {10, 10}
// {0, 1}
// 3
// 
// Returns: 2
// 
// The same example as before, except time is equal to 3 minutes. This extra minute allows you to meet both buses.
// 
// 3)
// 777
// {10,20,30,40,50,60,70,80,90,100,
// 110,120,130,140,150,160,170,180,190,200,
// 210,220,230,240,250,260,270,280,290,300,
// 310,320,330,340,350,360,370,380,390,400,
// 410,420,430,440,450,460,470,480,490,500}
// {10,20,30,40,50,60,70,80,90,100,
// 110,120,130,140,150,160,170,180,190,200,
// 210,220,230,240,250,260,270,280,290,300,
// 310,320,330,340,350,360,370,380,390,400,
// 410,420,430,440,450,460,470,480,490,500}
// 333
// 
// Returns: 50
// 
// 4)
// 5
// {0,0,0}
// {4,5,6}
// 10
// 
// Returns: 3
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
