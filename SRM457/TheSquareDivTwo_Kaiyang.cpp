#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;


class TheSquareDivTwo {
public:
  vector <string> solve(vector <string> board) {
    int size = board.size();
    vector<int> v(size, 0);
    int j = 0;
    for (; j < size; ++j) {
      string str = board[j];
      for (auto i : str) {
        if (i == 'C')
          ++v[j];
      }
    }
    vector<string> ret;
    for (j = 0; j < size; ++j) {
      string str;
      for (int i = 0; i < size; ++i) {
        str += (v[i] >= size ? 'C' : '.');
        ++v[i];
      }
      ret.push_back(str);
    }
    return ret;
  }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, vector <string> p1) {
  cout << "Test " << testNum << ": [" << "{";
  for (int i = 0; int(p0.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << "\"" << p0[i] << "\"";
  }
  cout << "}";
  cout << "]" << endl;
  TheSquareDivTwo *obj;
  vector <string> answer;
  obj = new TheSquareDivTwo();
  clock_t startTime = clock();
  answer = obj->solve(p0);
  clock_t endTime = clock();
  delete obj;
  bool res;
  res = true;
  cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
  if (hasAnswer) {
    cout << "Desired answer:" << endl;
    cout << "\t" << "{";
    for (int i = 0; int(p1.size()) > i; ++i) {
      if (i > 0) {
        cout << ",";
      }
      cout << "\"" << p1[i] << "\"";
    }
    cout << "}" << endl;
  }
  cout << "Your answer:" << endl;
  cout << "\t" << "{";
  for (int i = 0; int(answer.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << "\"" << answer[i] << "\"";
  }
  cout << "}" << endl;
  if (hasAnswer) {
    if (answer.size() != p1.size()) {
      res = false;
    } else {
      for (int i = 0; int(answer.size()) > i; ++i) {
        if (answer[i] != p1[i]) {
          res = false;
        }
      }
    }
  }
  if (!res) {
    cout << "DOESN'T MATCH!!!!" << endl;
  } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
    cout << "FAIL the timeout" << endl;
    res = false;
  } else if (hasAnswer) {
    cout << "Match :-)" << endl;
  } else {
    cout << "OK, but is it right?" << endl;
  }
  cout << "" << endl;
  return res;
}
int main() {
  bool all_right;
  all_right = true;
	
  vector <string> p0;
  vector <string> p1;
	
  {
    // ----- test 0 -----
    string t0[] = {"..","C."};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    string t1[] = {"..",".C"};
    p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
    all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 1 -----
    string t0[] = {"CC",".C"};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    string t1[] = {"C.","CC"};
    p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
    all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 2 -----
    string t0[] = {".C..","CC.C","..C.","CCCC"};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    string t1[] = {"...C",".C.C",".C.C","CCCC"};
    p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
    all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 3 -----
    string t0[] = {"...CCC","...CCC","...CCC","CCC...","CCC...","CCC..."};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    string t1[] = {"......","......","......","CCCCCC","CCCCCC","CCCCCC"};
    p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
    all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 4 -----
    string t0[] = {".....C","....CC","...CCC","..CCCC",".CCCCC","CCCCCC"};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    string t1[] = {".....C","....CC","...CCC","..CCCC",".CCCCC","CCCCCC"};
    p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
    all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
    // ------------------
  }
	
  {
    // ----- test 5 -----
    string t0[] = {"C.C..C.C..C..C.","CCC...C..CCC.C.","......CC...CCCC",".C..CC.C.C.C.C.","C....C.C......C",".....C..CCCCC.C","CCC.......CCCCC","..C.C..C.C...C.","CCC....CCC.CC..","CC.CCCC.CCCC...",".C..C.CC.C.CC.C","C.CCCC..CC..C.C",".CCCC.CCCCCC...","..C...C.CCC.CC.","CCCC..CCC.C...."};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    string t1[] = {"...............","...............","...............","...............","...............",".........C..C..",".........C.CC..",".C....C.CCCCC.C",".C.C.CC.CCCCCCC","CCCC.CC.CCCCCCC","CCCC.CCCCCCCCCC","CCCCCCCCCCCCCCC","CCCCCCCCCCCCCCC","CCCCCCCCCCCCCCC","CCCCCCCCCCCCCCC"};
    p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
    all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
    // ------------------
  }
	
  if (all_right) {
    cout << "You're a stud (at least on the example cases)!" << endl;
  } else {
    cout << "Some of the test cases had errors." << endl;
  }
  return 0;
}
// PROBLEM STATEMENT
// John and Brus like puzzles. They have been playing a new game which involves placing checkers on a square board. The board is a grid containing the same number of columns and rows.
// 
// The game begins with John placing checkers on specific cells of the board.  Then, R[i] is calculated for each row i, where R[i] is the number of checkers in the i-th row.  Brus must then move the checkers in such a way that for each column i in the final board, the number of checkers in that column is equal to R[i].  Note that R[i] is calculated for the initial placement of checkers and is not modified afterwards.  In a single turn, Brus can move a checker up, down, left or right into an adjacent empty cell.  He may use as many turns as necessary to reach the goal.
// 
// You are given a vector <string> board, where the j-th character of the i-th element is uppercase 'C' if the cell at row i, column j contains a checker and '.' otherwise.  Return the final placement of checkers using the same format as the input.  Since there may be many possible final placements, return the one that comes first lexicographically.
// 
// DEFINITION
// Class:TheSquareDivTwo
// Method:solve
// Parameters:vector <string>
// Returns:vector <string>
// Method signature:vector <string> solve(vector <string> board)
// 
// 
// NOTES
// -The lexicographically earlier of two vector <string>s is the one that has the lexicographically earlier string in the first position at which they differ.
// -The lexicographically earlier of two strings is the one that has the earlier character (using ASCII ordering) at the first position at which they differ.
// -In ASCII ordering, a dot character '.' comes before 'C'.
// 
// 
// CONSTRAINTS
// -board will contain exactly n elements, where n is between 1 and 50, inclusive.
// -Each element of board will contain exactly n characters.
// -Each element of board will contain only uppercase 'C' or '.' .
// 
// 
// EXAMPLES
// 
// 0)
// {"..",
//  "C."}
// 
// Returns: {"..", ".C" }
// 
// R[0] is 0. R[1] is 1.
// 
// The final placement needs to have 0 checkers in the first column and 1 checker in the last column. Brus can move the checker to two different positions in order to accomplish the goal:
// 
// 
// ..   .C
// .C , ..
// 
// Note that the first one comes first lexicographically.
// 
// 1)
// {"CC",
//  ".C"}
// 
// Returns: {"C.", "CC" }
// 
// 
// CC -> CC -> C.
// .C    C.    CC
// 
// 
// 2)
// {".C..",
//  "CC.C",
//  "..C.",
//  "CCCC"}
// 
// Returns: {"...C", ".C.C", ".C.C", "CCCC" }
// 
// 
// 
// 3)
// {"...CCC",
//  "...CCC",
//  "...CCC",
//  "CCC...",
//  "CCC...",
//  "CCC..."}
// 
// Returns: {"......", "......", "......", "CCCCCC", "CCCCCC", "CCCCCC" }
// 
// 
// 
// 4)
// {".....C",
//  "....CC",
//  "...CCC",
//  "..CCCC",
//  ".CCCCC",
//  "CCCCCC"}
// 
// Returns: {".....C", "....CC", "...CCC", "..CCCC", ".CCCCC", "CCCCCC" }
// 
// No move was necessary in this case.
// 
// 5)
// {"C.C..C.C..C..C.",
//  "CCC...C..CCC.C.",
//  "......CC...CCCC",
//  ".C..CC.C.C.C.C.",
//  "C....C.C......C",
//  ".....C..CCCCC.C",
//  "CCC.......CCCCC",
//  "..C.C..C.C...C.",
//  "CCC....CCC.CC..",
//  "CC.CCCC.CCCC...",
//  ".C..C.CC.C.CC.C",
//  "C.CCCC..CC..C.C",
//  ".CCCC.CCCCCC...",
//  "..C...C.CCC.CC.",
//  "CCCC..CCC.C...."}
// 
// Returns: {"...............", "...............", "...............", "...............", "...............", ".........C..C..", ".........C.CC..", ".C....C.CCCCC.C", ".C.C.CC.CCCCCCC", "CCCC.CC.CCCCCCC", "CCCC.CCCCCCCCCC", "CCCCCCCCCCCCCCC", "CCCCCCCCCCCCCCC", "CCCCCCCCCCCCCCC", "CCCCCCCCCCCCCCC" }
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!

