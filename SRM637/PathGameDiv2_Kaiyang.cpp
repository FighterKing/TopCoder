#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;


class PathGameDiv2 {
public:
  int calc(vector <string> board) {
    int countW = min(helper(board, 0), helper(board, 1));
    int countB = 0;
    for (auto str : board) {
      for (auto c : str)
        countB += (c == '#');
    }
    return  2 * board[0].size() - countW - countB;
  }

  int helper(const vector<string>& board, int start) {
    int x = 0;
    int count = 0;
    while (x < board[0].size()) {
      if (board[start][x] == '.')
        ++x;
      else
        start = !start;
      ++count;        
    }
    return count;
  }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
  cout << "Test " << testNum << ": [" << "{";
  for (int i = 0; int(p0.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << "\"" << p0[i] << "\"";
  }
  cout << "}";
  cout << "]" << endl;
  PathGameDiv2 *obj;
  int answer;
  obj = new PathGameDiv2();
  clock_t startTime = clock();
  answer = obj->calc(p0);
  clock_t endTime = clock();
  delete obj;
  bool res;
  res = true;
  cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
  if (hasAnswer) {
    cout << "Desired answer:" << endl;
    cout << "\t" << p1 << endl;
  }
  cout << "Your answer:" << endl;
  cout << "\t" << answer << endl;
  if (hasAnswer) {
    res = answer == p1;
  }
  if (!res) {
    cout << "DOESN'T MATCH!!!!" << endl;
  } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
    cout << "FAIL the timeout" << endl;
    res = false;
  } else if (hasAnswer) {
    cout << "Match :-)" << endl;
  } else {
    cout << "OK, but is it right?" << endl;
  }
  cout << "" << endl;
  return res;
}
int main() {
  bool all_right;
  all_right = true;

  vector <string> p0;
  int p1;

  {
    // ----- test 0 -----
    string t0[] = {"#....","...#."};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    p1 = 2;
    all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
    // ------------------
  }

  {
    // ----- test 1 -----
    string t0[] = {"#","."};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    p1 = 0;
    all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
    // ------------------
  }

  {
    // ----- test 2 -----
    string t0[] = {".","."};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    p1 = 1;
    all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
    // ------------------
  }

  {
    // ----- test 3 -----
    string t0[] = {"....#.##.....#...........","..#......#.......#..#...."};
    p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
    p1 = 13;
    all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
    // ------------------
  }

  if (all_right) {
    cout << "You're a stud (at least on the example cases)!" << endl;
  } else {
    cout << "Some of the test cases had errors." << endl;
  }
  return 0;
}
// PROBLEM STATEMENT
// Cat Snuke is playing the Path Game.
// 
// The Path Game is played on a rectangular grid of square cells.
// The grid has 2 rows and some positive number of columns.
// Each cell is either black or white.
// 
// A left-to-right path in the grid is a sequence of white cells such
// that the first cell in the sequence is in the leftmost column, the
// last cell in the sequence is in the rightmost column, and each pair
// of consecutive cells shares a common side.
// 
// The initial coloring of the grid is such that there is at least one
// left-to-right path.
// You are given this initial coloring as a vector <string> board with
// two elements.
// For each i and j, board[i][j] is either '#' (representing a black
// cell) or '.' (representing a white cell).
// 
// Snuke may color some of the white cells black.
// After he does so, there must still be at least one left-to-right
// path left on the board.
// The goal of the game is to color as many cells black as possible.
// Compute and return the largest number of cells Snuke can color
// black.
// (Note that the cells that are already black do not count.)
// 
// DEFINITION
// Class:PathGameDiv2
// Method:calc
// Parameters:vector <string>
// Returns:int
// Method signature:int calc(vector <string> board)
// 
// 
// CONSTRAINTS
// -board will contain 2 elements.
// -Each element in board will contain between 1 and 50 characters,
// inclusive.
// -All elements in board will have the same length.
// -Each character in board will be '#' or '.'.
// -The grid described by board will contain a left-to-right path.
// 
// 
// EXAMPLES
// 
// 0)
// {"#...."
// ,"...#."}
// 
// Returns: 2
// 
// Snuke can color at most two white cells black.
// One possible final state of the board looks as follows:
// 
// #....
// ..###
// 
// 
// 1)
// {"#"
// ,"."}
// 
// Returns: 0
// 
// Snuke can't color any cells.
// 
// 2)
// {"."
// ,"."}
// 
// Returns: 1
// 
// 
// 
// 3)
// {"....#.##.....#..........."
// ,"..#......#.......#..#...."}
// 
// Returns: 13
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
