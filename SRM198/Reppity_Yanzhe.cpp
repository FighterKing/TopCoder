#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;


class Reppity {
public:
	int longestRep(string input) {
		int N = input.size();
		int s = N / 2;
		for (; s >= 1; s--) {
			for (int i = 0; i + 2 * s <= N; i++) { // [i, i+s-1]
				for (int j = i+s; j + s <= N; j++) { // [j, j+s-1]
					if (input.substr(i, s) == input.substr(j, s))
						return s;
				}
			}
		}
		return 0;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"";
	cout << "]" << endl;
	Reppity *obj;
	int answer;
	obj = new Reppity();
	clock_t startTime = clock();
	answer = obj->longestRep(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	int p1;
	
	{
	// ----- test 0 -----
	p0 = "ABCDEXXXYYYZZZABCDEZZZYYYXXX";
	p1 = 5;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "abcdabcdabcdabCD";
	p1 = 6;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxy";
	p1 = 25;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "againANDagainANDagainANDagainANDagainANDagain";
	p1 = 21;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX";
	p1 = 0;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// Given a string, input, with up to 50 characters, find the length of the longest substring that appears at least twice (non-overlapping) in input. If no substring appears twice, non-overlapping, return 0.
// Strings are case sensitive, and only upper case letters and lower case letters are allowed in input.
// 
// For example, in the string "ABCDEXXXYYYZZZABCDEZZZYYYXXX" the longest substring which appears at least twice is "ABCDE". These two substrings do not overlap so you would return 5.
// 
// 
// DEFINITION
// Class:Reppity
// Method:longestRep
// Parameters:string
// Returns:int
// Method signature:int longestRep(string input)
// 
// 
// NOTES
// -We are looking for subSTRINGS not subSEQUENCES. All of the elements of a substring appear consecutively in the original string. In other words, the substring can be formed from the original string by deleting zero or more characters from the begining and deleting zero or more characters from the end, but NO deletions from the middle are allowed.
// 
// 
// CONSTRAINTS
// -input will contain between 1 and 50 characters inclusive.
// -Each character in input will be between 'a' and 'z' inclusive or between 'A' and 'Z' inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// "ABCDEXXXYYYZZZABCDEZZZYYYXXX"
// 
// Returns: 5
// 
// The example from above.
// 
// 1)
// "abcdabcdabcdabCD"
// 
// Returns: 6
// 
// "abcdab"+"cd"+"abcdab"+"CD"
// 
// 2)
// "abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxy"
// 
// Returns: 25
// 
// 3)
// "againANDagainANDagainANDagainANDagainANDagain"
// 
// Returns: 21
// 
// 4)
// "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX"
// 
// Returns: 0
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
